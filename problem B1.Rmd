---
title: "Problem B.1"
author: "Haonan LI"
date: "2025-01-28"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r cars}
# (a) Create a function

# Parzen window prediction function
PredictNearestNeighborsParzen1D <- function(yval, xval, xpred, WindowSize) {
  # Number of prediction points
  n <- length(xpred)
  # Initialize predictions vector
  preds <- numeric(n)
  
  for (i in 1:n) {
    # Calculate weights using the Gaussian kernel
    weights <- dnorm((xval - xpred[i]) / WindowSize)
    # Normalize weights
    weights <- weights / sum(weights)
    
    # Compute weighted average to predict the response
    preds[i] <- sum(weights * yval)
  }
  # Return predictions
  return(preds)
}

# (b)
# Set a random seed for reproducibility
set.seed(123)

# Number of samples for in-sample and out-of-sample datasets
n_samples <- 200

# Generate random independent variables (x) uniformly in [-2, 2]
x_in <- runif(n_samples, -2, 2)  
x_out <- runif(n_samples, -2, 2) 

# Generate responses for the given model with added noise
y_in <- 0.05 * x_in^5 - 3 * x_in^2 + rnorm(n_samples, 0, 1)
y_out <- 0.05 * x_out^5 - 3 * x_out^2 + rnorm(n_samples, 0, 1)

# (c)
# Create a grid of predictors
x_grid <- seq(-2, 2, by = 0.01)

# Apply Parzen window method with D = 0.1 and D = 0.5
y_preds_D01 <- PredictNearestNeighborsParzen1D(y_in, x_in, x_grid, 0.1)
y_preds_D05 <- PredictNearestNeighborsParzen1D(y_in, x_in, x_grid, 0.5)

# Plot the in-sample data points and prediction curves
plot(x_in, y_in, pch = 20, col = "gray", main = "Parzen Window Predictions 
     with Different D Values", xlab = "X", ylab = "Y" )
lines(x_grid, y_preds_D01, col = "red", lwd = 2)
lines(x_grid, y_preds_D05, col = "blue", lwd = 2)
legend("topright", legend = c("D = 0.1", "D = 0.5"), 
       col = c("red", "blue"), lwd = 2) 

# (d)
# Define the range of D values
D_values <- seq(0.05, 1, by = 0.05)

# Initialize vectors to store MSE for in-sample and out-of-sample data
mse_in <- numeric(length(D_values))
mse_out <- numeric(length(D_values))

# Loop through each D value to calculate MSE
for (i in seq_along(D_values)) {
  D <- D_values[i]
  
  # Calculate in-sample MSE
  y_pred_in <- PredictNearestNeighborsParzen1D(y_in, x_in, x_in, D)
  mse_in[i] <- mean((y_in - y_pred_in)^2, na.rm = TRUE)
  
  # Calculate out-of-sample MSE
  y_pred_out <- PredictNearestNeighborsParzen1D(y_in, x_in, x_out, D)
  mse_out[i] <- mean((y_out - y_pred_out)^2, na.rm = TRUE)
}

# Plot MSE curves
plot( D_values, mse_in, type = "l", col = "blue", 
      ylim = range(c(mse_in, mse_out)),  xlab = "Window Size (D)",
      ylab = "MSE", main = "MSE vs. Window Size" )

# Add the out-of-sample MSE curve
lines(D_values, mse_out, col = "red", lty = 2, lwd = 2)

# Add a legend to distinguish the curves
legend("topright", legend = c("In-sample MSE", "Out-of-sample MSE"), 
  col = c("blue", "red"), lty = c(1, 2), lwd = 2)

# (e)
# Select the best D based on the minimum out-of-sample MSE
best_D <- D_values[which.min(mse_out)]

# Output the best D and its corresponding out-of-sample MSE
cat("Best D:", best_D, "\n")
cat("Minimum Out-of-sample MSE:", min(mse_out), "\n")


  
```

